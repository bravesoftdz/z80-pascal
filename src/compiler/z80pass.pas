UNIT Z80PasS;
(* Scanner generated by Coco/R (Pascal version) *)

INTERFACE

VAR
  src:         FILE;         (*source/list files. To be opened by the main pgm*)
  lst:         TEXT;
  directory:   STRING;       (*of source file*)
  line, col:   INTEGER;      (*line and column of current symbol*)
  len:         LONGINT;      (*length of current symbol*)
  pos:         LONGINT;      (*file position of current symbol*)
  nextLine:    INTEGER;      (*line of lookahead symbol*)
  nextCol:     INTEGER;      (*column of lookahead symbol*)
  nextLen:     LONGINT;      (*length of lookahead symbol*)
  nextPos:     LONGINT;      (*file position of lookahead symbol*)
  errors:      INTEGER;      (*number of detected errors*)
  Error:       PROCEDURE (nr, line, col: INTEGER; pos: LONGINT);

PROCEDURE Get (VAR sym: INTEGER);
(* Gets next symbol from source file *)

PROCEDURE GetString (pos: LONGINT; len: INTEGER; VAR s: STRING);
(* Retrieves exact string of max length len from position pos in source file *)

PROCEDURE GetName (pos: LONGINT; len: INTEGER; VAR s: STRING);
(* Retrieves name of symbol of length len at position pos in source file *)

FUNCTION CharAt (pos: LONGINT): CHAR;
(* Returns exact character at position pos in source file *)

PROCEDURE _Reset;
(* Reads and stores source file internally *)

IMPLEMENTATION
USES Z80PasG (* Symbol Constants *);

CONST
  no_Sym = NO_SYMB; (*error token code*)
  (* not only for errors but also for not finished states of scanner analysis *)
  eof = #26; (*MS-DOS eof*)
  LF  = #10;
  CR  = #13;
  EF  = #0;
  EL  = CR;
  BlkSize = 16384;
TYPE
  BufBlock   = ARRAY [0 .. BlkSize-1] OF CHAR;
  Buffer     = ARRAY [0 .. 31] OF ^BufBlock;
  StartTable = ARRAY [0 .. 255] OF INTEGER;
  GetCH      = FUNCTION (pos: LONGINT) : CHAR;
VAR
  lastCh,
  ch:        CHAR;       (*current input character*)
  curLine:   INTEGER;    (*current input line (may be higher than line)*)
  lineStart: LONGINT;    (*start position of current line*)
  apx:       LONGINT;    (*length of appendix (CONTEXT phrase)*)
  oldEols:   INTEGER;    (*number of _EOLs in a comment*)
  bp, bp0:   LONGINT;    (*current position in buf
                           (bp0: position of current token)*)
  LBlkSize:  LONGINT;    (*BlkSize*)
  inputLen:  LONGINT;    (*source file size*)
  buf:       Buffer;     (*source buffer for low-level access*)
  start:     StartTable; (*start state for every character*)
  CurrentCh: GetCH;

PROCEDURE Err (nr, line, col: INTEGER; pos: LONGINT); FAR;
  BEGIN
    INC(errors)
  END;

PROCEDURE NextCh;
(* Return global variable ch *)
  BEGIN
    lastCh := ch; INC(bp); ch := CurrentCh(bp);
    IF (ch = EL) OR (ch = LF) AND (lastCh <> EL) THEN BEGIN
      INC(curLine); lineStart := bp
    END
  END;

FUNCTION Comment: BOOLEAN;
  LABEL
    999;
  VAR
    level, startLine: INTEGER;
    oldLineStart : LONGINT;
  BEGIN
    level := 1; startLine := curLine; oldLineStart := lineStart;
    IF (ch = '{') THEN BEGIN
      NextCh;
      WHILE TRUE DO BEGIN
        IF (ch = '}') THEN BEGIN
          DEC(level); oldEols := curLine - startLine; NextCh;
          IF level = 0 THEN BEGIN Comment := TRUE; GOTO 999; END;
        END ELSE IF ch = EF THEN BEGIN Comment := FALSE; GOTO 999; END
        ELSE NextCh;
      END; (* WHILE TRUE *)
    END;
    IF (ch = '(') THEN BEGIN
      NextCh;
      IF (ch = '*') THEN BEGIN
        NextCh;
        WHILE TRUE DO BEGIN
          IF (ch = '*') THEN BEGIN
            NextCh;
            IF (ch = ')') THEN BEGIN
              DEC(level); NextCh;
              IF level = 0 THEN BEGIN Comment := TRUE; GOTO 999; END
            END
          END ELSE IF ch = EF THEN BEGIN Comment := FALSE; GOTO 999; END
          ELSE NextCh;
        END; (* WHILE TRUE *)
      END ELSE BEGIN
        IF (ch = CR) OR (ch = LF) THEN BEGIN
          DEC(curLine); lineStart := oldLineStart
        END;
        DEC(bp); ch := lastCh; Comment := FALSE;
      END;
    END;
    Comment := FALSE;
    999:
  END;

PROCEDURE Get (VAR sym: INTEGER);
  VAR
    state: INTEGER;

  FUNCTION Equal (s: STRING): BOOLEAN;
    VAR
      i: INTEGER;
      q: LONGINT;
    BEGIN
      IF nextLen <> Length(s) THEN BEGIN Equal := FALSE; EXIT END;
      i := 1; q := bp0;
      WHILE i <= nextLen DO BEGIN
        IF CurrentCh(q) <> s[i] THEN BEGIN Equal := FALSE; EXIT END;
        INC(i); INC(q)
      END;
      Equal := TRUE
    END;

  PROCEDURE CheckLiteral;
    BEGIN
      CASE CurrentCh(bp0) OF
        'A': IF Equal('A') THEN BEGIN sym := _ASym; 
             END ELSE IF Equal('ADC') THEN BEGIN sym := ADCSym; 
             END ELSE IF Equal('ADD') THEN BEGIN sym := ADDSym; 
             END ELSE IF Equal('AF') THEN BEGIN sym := AFSym; 
             END ELSE IF Equal('AND') THEN BEGIN sym := ANDSym; 
             END ELSE IF Equal('ARRAY') THEN BEGIN sym := ARRAYSym; 
             END ELSE IF Equal('ASM') THEN BEGIN sym := ASMSym; 
             END;
        'B': IF Equal('B') THEN BEGIN sym := _BSym; 
             END ELSE IF Equal('BC') THEN BEGIN sym := BCSym; 
             END ELSE IF Equal('BEGIN') THEN BEGIN sym := BEGINSym; 
             END ELSE IF Equal('BIT') THEN BEGIN sym := BITSym; 
             END;
        'C': IF Equal('C') THEN BEGIN sym := _CSym; 
             END ELSE IF Equal('CALL') THEN BEGIN sym := CALLSym; 
             END ELSE IF Equal('CASE') THEN BEGIN sym := CASESym; 
             END ELSE IF Equal('CCF') THEN BEGIN sym := CCFSym; 
             END ELSE IF Equal('CONST') THEN BEGIN sym := CONSTSym; 
             END ELSE IF Equal('CP') THEN BEGIN sym := CPSym; 
             END ELSE IF Equal('CPD') THEN BEGIN sym := CPDSym; 
             END ELSE IF Equal('CPDR') THEN BEGIN sym := CPDRSym; 
             END ELSE IF Equal('CPI') THEN BEGIN sym := CPISym; 
             END ELSE IF Equal('CPIR') THEN BEGIN sym := CPIRSym; 
             END ELSE IF Equal('CPL') THEN BEGIN sym := CPLSym; 
             END;
        'D': IF Equal('D') THEN BEGIN sym := _DSym; 
             END ELSE IF Equal('DAA') THEN BEGIN sym := DAASym; 
             END ELSE IF Equal('DE') THEN BEGIN sym := DESym; 
             END ELSE IF Equal('DEC') THEN BEGIN sym := DECSym; 
             END ELSE IF Equal('DI') THEN BEGIN sym := DISym; 
             END ELSE IF Equal('DIV') THEN BEGIN sym := DIVSym; 
             END ELSE IF Equal('DO') THEN BEGIN sym := DOSym; 
             END ELSE IF Equal('DOWNTO') THEN BEGIN sym := DOWNTOSym; 
             END;
        'E': IF Equal('E') THEN BEGIN sym := _ESym; 
             END ELSE IF Equal('EI') THEN BEGIN sym := EISym; 
             END ELSE IF Equal('ELSE') THEN BEGIN sym := ELSESym; 
             END ELSE IF Equal('END') THEN BEGIN sym := ENDSym; 
             END ELSE IF Equal('EX') THEN BEGIN sym := EXSym; 
             END ELSE IF Equal('EXX') THEN BEGIN sym := EXXSym; 
             END;
        'F': IF Equal('FILE') THEN BEGIN sym := FILESym; 
             END ELSE IF Equal('FOR') THEN BEGIN sym := FORSym; 
             END ELSE IF Equal('FORWARD') THEN BEGIN sym := FORWARDSym; 
             END ELSE IF Equal('FUNCTION') THEN BEGIN sym := FUNCTIONSym; 
             END;
        'H': IF Equal('H') THEN BEGIN sym := _HSym; 
             END ELSE IF Equal('HALT') THEN BEGIN sym := HALTSym; 
             END ELSE IF Equal('HL') THEN BEGIN sym := HLSym; 
             END;
        'I': IF Equal('IF') THEN BEGIN sym := IFSym; 
             END ELSE IF Equal('IM') THEN BEGIN sym := IMSym; 
             END ELSE IF Equal('IN') THEN BEGIN sym := INSym; 
             END ELSE IF Equal('INC') THEN BEGIN sym := INCSym; 
             END ELSE IF Equal('IND') THEN BEGIN sym := INDSym; 
             END ELSE IF Equal('INDR') THEN BEGIN sym := INDRSym; 
             END ELSE IF Equal('INI') THEN BEGIN sym := INISym; 
             END ELSE IF Equal('INIR') THEN BEGIN sym := INIRSym; 
             END ELSE IF Equal('IX') THEN BEGIN sym := IXSym; 
             END ELSE IF Equal('IY') THEN BEGIN sym := IYSym; 
             END;
        'J': IF Equal('JP') THEN BEGIN sym := JPSym; 
             END ELSE IF Equal('JR') THEN BEGIN sym := JRSym; 
             END;
        'L': IF Equal('L') THEN BEGIN sym := _LSym; 
             END ELSE IF Equal('LD') THEN BEGIN sym := LDSym; 
             END ELSE IF Equal('LDD') THEN BEGIN sym := LDDSym; 
             END ELSE IF Equal('LDDR') THEN BEGIN sym := LDDRSym; 
             END ELSE IF Equal('LDI') THEN BEGIN sym := LDISym; 
             END ELSE IF Equal('LDIR') THEN BEGIN sym := LDIRSym; 
             END;
        'M': IF Equal('M') THEN BEGIN sym := _MSym; 
             END ELSE IF Equal('MOD') THEN BEGIN sym := MODSym; 
             END;
        'N': IF Equal('NC') THEN BEGIN sym := NCSym; 
             END ELSE IF Equal('NEG') THEN BEGIN sym := NEGSym; 
             END ELSE IF Equal('NIL') THEN BEGIN sym := NILSym; 
             END ELSE IF Equal('NOP') THEN BEGIN sym := NOPSym; 
             END ELSE IF Equal('NOT') THEN BEGIN sym := NOTSym; 
             END ELSE IF Equal('NP') THEN BEGIN sym := NPSym; 
             END ELSE IF Equal('NZ') THEN BEGIN sym := NZSym; 
             END;
        'O': IF Equal('OF') THEN BEGIN sym := OFSym; 
             END ELSE IF Equal('OR') THEN BEGIN sym := ORSym; 
             END ELSE IF Equal('OTDR') THEN BEGIN sym := OTDRSym; 
             END ELSE IF Equal('OTIR') THEN BEGIN sym := OTIRSym; 
             END ELSE IF Equal('OUT') THEN BEGIN sym := OUTSym; 
             END ELSE IF Equal('OUTD') THEN BEGIN sym := OUTDSym; 
             END ELSE IF Equal('OUTI') THEN BEGIN sym := OUTISym; 
             END;
        'P': IF Equal('P') THEN BEGIN sym := _PSym; 
             END ELSE IF Equal('PACKED') THEN BEGIN sym := PACKEDSym; 
             END ELSE IF Equal('PC') THEN BEGIN sym := PCSym; 
             END ELSE IF Equal('PE') THEN BEGIN sym := PESym; 
             END ELSE IF Equal('PO') THEN BEGIN sym := POSym; 
             END ELSE IF Equal('POP') THEN BEGIN sym := POPSym; 
             END ELSE IF Equal('PROCEDURE') THEN BEGIN sym := PROCEDURESym; 
             END ELSE IF Equal('PROGRAM') THEN BEGIN sym := PROGRAMSym; 
             END ELSE IF Equal('PUSH') THEN BEGIN sym := PUSHSym; 
             END;
        'R': IF Equal('RECORD') THEN BEGIN sym := RECORDSym; 
             END ELSE IF Equal('REPEAT') THEN BEGIN sym := REPEATSym; 
             END ELSE IF Equal('RES') THEN BEGIN sym := RESSym; 
             END ELSE IF Equal('RET') THEN BEGIN sym := RETSym; 
             END ELSE IF Equal('RETI') THEN BEGIN sym := RETISym; 
             END ELSE IF Equal('RETN') THEN BEGIN sym := RETNSym; 
             END ELSE IF Equal('RL') THEN BEGIN sym := RLSym; 
             END ELSE IF Equal('RLA') THEN BEGIN sym := RLASym; 
             END ELSE IF Equal('RLC') THEN BEGIN sym := RLCSym; 
             END ELSE IF Equal('RLCA') THEN BEGIN sym := RLCASym; 
             END ELSE IF Equal('RLD') THEN BEGIN sym := RLDSym; 
             END ELSE IF Equal('RR') THEN BEGIN sym := RRSym; 
             END ELSE IF Equal('RRA') THEN BEGIN sym := RRASym; 
             END ELSE IF Equal('RRC') THEN BEGIN sym := RRCSym; 
             END ELSE IF Equal('RRD') THEN BEGIN sym := RRDSym; 
             END ELSE IF Equal('RST') THEN BEGIN sym := RSTSym; 
             END;
        'S': IF Equal('SBC') THEN BEGIN sym := SBCSym; 
             END ELSE IF Equal('SCF') THEN BEGIN sym := SCFSym; 
             END ELSE IF Equal('SET') THEN BEGIN sym := SETSym; 
             END ELSE IF Equal('SLA') THEN BEGIN sym := SLASym; 
             END ELSE IF Equal('SP') THEN BEGIN sym := SPSym; 
             END ELSE IF Equal('SRA') THEN BEGIN sym := SRASym; 
             END ELSE IF Equal('SUB') THEN BEGIN sym := SUBSym; 
             END;
        'T': IF Equal('THEN') THEN BEGIN sym := THENSym; 
             END ELSE IF Equal('TO') THEN BEGIN sym := TOSym; 
             END ELSE IF Equal('TYPE') THEN BEGIN sym := TYPESym; 
             END;
        'U': IF Equal('UNTIL') THEN BEGIN sym := UNTILSym; 
             END;
        'V': IF Equal('VAR') THEN BEGIN sym := VARSym; 
             END;
        'W': IF Equal('WHILE') THEN BEGIN sym := WHILESym; 
             END ELSE IF Equal('WITH') THEN BEGIN sym := WITHSym; 
             END;
        'X': IF Equal('XOR') THEN BEGIN sym := XORSym; 
             END;
        'Z': IF Equal('Z') THEN BEGIN sym := _ZSym; 
             END;
      ELSE BEGIN END
      END
    END;

  BEGIN (*Get*)
    WHILE (ch = ' ') OR
          ((ch >= CHR(9)) AND (ch <= CHR(13))) DO NextCh;
    IF ((ch = '{') OR (ch = '(')) AND Comment THEN BEGIN Get(sym); EXIT; END;
    pos := nextPos;   nextPos := bp;
    col := nextCol;   nextCol := bp - lineStart;
    line := nextLine; nextLine := curLine;
    len := nextLen;   nextLen := 0;
    apx := 0; state := start[ORD(ch)]; bp0 := bp;
    WHILE TRUE DO BEGIN
      NextCh; INC(nextLen);
      CASE state OF
         1: IF ((ch >= '0') AND (ch <= '9') OR
               (ch >= 'A') AND (ch <= 'Z')) THEN BEGIN 
            END ELSE BEGIN sym := identifierSym; CheckLiteral; EXIT; END;
         2: BEGIN bp := bp - apx - 1; DEC(nextLen, apx); NextCh; BEGIN sym := integerSym; EXIT; END; END;
         3: IF ((ch >= '0') AND (ch <= '9') OR
               (ch >= 'A') AND (ch <= 'F')) THEN BEGIN state := 4; 
            END ELSE BEGIN sym := no_Sym; EXIT; END;
         4: IF ((ch >= '0') AND (ch <= '9') OR
               (ch >= 'A') AND (ch <= 'F')) THEN BEGIN 
            END ELSE BEGIN sym := hexintegerSym; EXIT; END;
         5: IF ((ch >= '0') AND (ch <= '9')) THEN BEGIN 
            END ELSE IF (ch = 'E') THEN BEGIN state := 6; 
            END ELSE BEGIN sym := realSym; EXIT; END;
         6: IF ((ch >= '0') AND (ch <= '9')) THEN BEGIN state := 8; 
            END ELSE IF ((ch = '+') OR
                  (ch = '-')) THEN BEGIN state := 7; 
            END ELSE BEGIN sym := no_Sym; EXIT; END;
         7: IF ((ch >= '0') AND (ch <= '9')) THEN BEGIN state := 8; 
            END ELSE BEGIN sym := no_Sym; EXIT; END;
         8: IF ((ch >= '0') AND (ch <= '9')) THEN BEGIN 
            END ELSE BEGIN sym := realSym; EXIT; END;
         9: IF ((ch >= '0') AND (ch <= '9')) THEN BEGIN state := 11; 
            END ELSE IF ((ch = '+') OR
                  (ch = '-')) THEN BEGIN state := 10; 
            END ELSE BEGIN sym := no_Sym; EXIT; END;
        10: IF ((ch >= '0') AND (ch <= '9')) THEN BEGIN state := 11; 
            END ELSE BEGIN sym := no_Sym; EXIT; END;
        11: IF ((ch >= '0') AND (ch <= '9')) THEN BEGIN 
            END ELSE BEGIN sym := realSym; EXIT; END;
        12: IF ((ch <= CHR(12)) OR
               (ch >= CHR(14)) AND (ch <= '&') OR
               (ch >= '(')) THEN BEGIN 
            END ELSE IF (ch = CHR(39)) THEN BEGIN state := 14; 
            END ELSE BEGIN sym := no_Sym; EXIT; END;
        13: IF ((ch >= '0') AND (ch <= '9')) THEN BEGIN 
            END ELSE IF (ch = '.') THEN BEGIN state := 15; INC(apx) 
            END ELSE IF (ch = 'E') THEN BEGIN state := 9; 
            END ELSE BEGIN sym := integerSym; EXIT; END;
        14: IF (ch = CHR(39)) THEN BEGIN state := 12; 
            END ELSE BEGIN sym := stringSym; EXIT; END;
        15: IF ((ch >= '0') AND (ch <= '9')) THEN BEGIN state := 5; apx := 0 
            END ELSE IF (ch = '.') THEN BEGIN state := 2; INC(apx) 
            END ELSE BEGIN sym := no_Sym; EXIT; END;
        16: BEGIN sym := _semicolonSym; EXIT; END;
        17: IF (ch = '.') THEN BEGIN state := 24; 
            END ELSE BEGIN sym := _pointSym; EXIT; END;
        18: BEGIN sym := _equalSym; EXIT; END;
        19: BEGIN sym := _plusSym; EXIT; END;
        20: BEGIN sym := _minusSym; EXIT; END;
        21: BEGIN sym := _uparrowSym; EXIT; END;
        22: BEGIN sym := _lparenSym; EXIT; END;
        23: BEGIN sym := _rparenSym; EXIT; END;
        24: BEGIN sym := _point_pointSym; EXIT; END;
        25: BEGIN sym := _lbrackSym; EXIT; END;
        26: BEGIN sym := _rbrackSym; EXIT; END;
        27: BEGIN sym := _commaSym; EXIT; END;
        28: IF (ch = '=') THEN BEGIN state := 29; 
            END ELSE BEGIN sym := _colonSym; EXIT; END;
        29: BEGIN sym := _colon_equalSym; EXIT; END;
        30: BEGIN sym := _atSym; EXIT; END;
        31: IF (ch = '=') THEN BEGIN state := 33; 
            END ELSE IF (ch = '>') THEN BEGIN state := 35; 
            END ELSE BEGIN sym := _lessSym; EXIT; END;
        32: IF (ch = '=') THEN BEGIN state := 34; 
            END ELSE BEGIN sym := _greaterSym; EXIT; END;
        33: BEGIN sym := _less_equalSym; EXIT; END;
        34: BEGIN sym := _greater_equalSym; EXIT; END;
        35: BEGIN sym := _less_greaterSym; EXIT; END;
        36: BEGIN sym := _starSym; EXIT; END;
        37: BEGIN sym := _slashSym; EXIT; END;
        38: BEGIN sym := DJNZ_commaSym; EXIT; END;
        39: IF ((ch >= '0') AND (ch <= '9') OR
               (ch >= 'A') AND (ch <= 'I') OR
               (ch >= 'K') AND (ch <= 'Z')) THEN BEGIN state := 1; 
            END ELSE IF (ch = 'J') THEN BEGIN state := 40; 
            END ELSE BEGIN sym := identifierSym; CheckLiteral; EXIT; END;
        40: IF ((ch >= '0') AND (ch <= '9') OR
               (ch >= 'A') AND (ch <= 'M') OR
               (ch >= 'O') AND (ch <= 'Z')) THEN BEGIN state := 1; 
            END ELSE IF (ch = 'N') THEN BEGIN state := 41; 
            END ELSE BEGIN sym := identifierSym; CheckLiteral; EXIT; END;
        41: IF ((ch >= '0') AND (ch <= '9') OR
               (ch >= 'A') AND (ch <= 'Y')) THEN BEGIN state := 1; 
            END ELSE IF (ch = 'Z') THEN BEGIN state := 42; 
            END ELSE BEGIN sym := identifierSym; CheckLiteral; EXIT; END;
        42: IF ((ch >= '0') AND (ch <= '9') OR
               (ch >= 'A') AND (ch <= 'Z')) THEN BEGIN state := 1; 
            END ELSE IF (ch = ',') THEN BEGIN state := 38; 
            END ELSE BEGIN sym := identifierSym; CheckLiteral; EXIT; END;
        43: BEGIN sym := EOFSYMB; ch := #0; DEC(bp); EXIT END;
      ELSE BEGIN sym := no_Sym; EXIT (*NextCh already done*) END;
      END
    END
  END;

PROCEDURE GetString (pos: LONGINT; len: INTEGER; VAR s: STRING);
  VAR
    i: INTEGER;
    p: LONGINT;
  BEGIN
    IF len > 255 THEN len := 255;
    p := pos; i := 1;
    WHILE i <= len DO BEGIN
      s[i] := CharAt(p); INC(i); INC(p)
    END;
    s[0] := CHR(len);
  END;

PROCEDURE GetName (pos: LONGINT; len: INTEGER; VAR s: STRING);
  VAR
    i: INTEGER;
    p: LONGINT;
  BEGIN
    IF len > 255 THEN len := 255;
    p := pos; i := 1;
    WHILE i <= len DO BEGIN
      s[i] := CurrentCh(p); INC(i); INC(p)
    END;
    s[0] := CHR(len);
  END;

FUNCTION CharAt (pos: LONGINT): CHAR;
  VAR
    ch : CHAR;
  BEGIN
    IF pos >= inputLen THEN BEGIN CharAt := EF; EXIT; END;
    ch := buf[pos DIV LBlkSize]^[pos MOD LBlkSize];
    IF ch <> eof THEN CharAt := ch ELSE CharAt := EF
  END;

FUNCTION CapChAt (pos: LONGINT): CHAR; FAR;
  VAR
    ch : CHAR;
  BEGIN
    IF pos >= inputLen THEN BEGIN CapChAt := EF; EXIT; END;
    ch := upcase(buf[pos DIV LBlkSize]^[pos MOD LBlkSize]);
    IF ch <> eof THEN CapChAt := ch ELSE CapChAt := EF
  END;

PROCEDURE _Reset;
  VAR
    len: LONGINT;
    i, read: INTEGER;
  BEGIN (*assert: src has been opened*)
    len := FileSize(src); i := 0; inputLen := len;
    WHILE len > LBlkSize DO BEGIN
      NEW(buf[i]);
      read := BlkSize; BlockRead(src, buf[i]^, read);
      len := len - read; INC(i)
    END;
    NEW(buf[i]);
    read := len; BlockRead(src, buf[i]^, read);
    buf[i]^[read] := EF;
    curLine := 1; lineStart := -2; bp := -1;
    oldEols := 0; apx := 0; errors := 0;
    NextCh;
  END;

BEGIN
  CurrentCh := CapChAt;
  start[  0] := 43; start[  1] := 44; start[  2] := 44; start[  3] := 44; 
  start[  4] := 44; start[  5] := 44; start[  6] := 44; start[  7] := 44; 
  start[  8] := 44; start[  9] := 44; start[ 10] := 44; start[ 11] := 44; 
  start[ 12] := 44; start[ 13] := 44; start[ 14] := 44; start[ 15] := 44; 
  start[ 16] := 44; start[ 17] := 44; start[ 18] := 44; start[ 19] := 44; 
  start[ 20] := 44; start[ 21] := 44; start[ 22] := 44; start[ 23] := 44; 
  start[ 24] := 44; start[ 25] := 44; start[ 26] := 44; start[ 27] := 44; 
  start[ 28] := 44; start[ 29] := 44; start[ 30] := 44; start[ 31] := 44; 
  start[ 32] := 44; start[ 33] := 44; start[ 34] := 44; start[ 35] := 44; 
  start[ 36] :=  3; start[ 37] := 44; start[ 38] := 44; start[ 39] := 12; 
  start[ 40] := 22; start[ 41] := 23; start[ 42] := 36; start[ 43] := 19; 
  start[ 44] := 27; start[ 45] := 20; start[ 46] := 17; start[ 47] := 37; 
  start[ 48] := 13; start[ 49] := 13; start[ 50] := 13; start[ 51] := 13; 
  start[ 52] := 13; start[ 53] := 13; start[ 54] := 13; start[ 55] := 13; 
  start[ 56] := 13; start[ 57] := 13; start[ 58] := 28; start[ 59] := 16; 
  start[ 60] := 31; start[ 61] := 18; start[ 62] := 32; start[ 63] := 44; 
  start[ 64] := 30; start[ 65] :=  1; start[ 66] :=  1; start[ 67] :=  1; 
  start[ 68] := 39; start[ 69] :=  1; start[ 70] :=  1; start[ 71] :=  1; 
  start[ 72] :=  1; start[ 73] :=  1; start[ 74] :=  1; start[ 75] :=  1; 
  start[ 76] :=  1; start[ 77] :=  1; start[ 78] :=  1; start[ 79] :=  1; 
  start[ 80] :=  1; start[ 81] :=  1; start[ 82] :=  1; start[ 83] :=  1; 
  start[ 84] :=  1; start[ 85] :=  1; start[ 86] :=  1; start[ 87] :=  1; 
  start[ 88] :=  1; start[ 89] :=  1; start[ 90] :=  1; start[ 91] := 25; 
  start[ 92] := 44; start[ 93] := 26; start[ 94] := 21; start[ 95] := 44; 
  start[ 96] := 44; start[ 97] := 44; start[ 98] := 44; start[ 99] := 44; 
  start[100] := 44; start[101] := 44; start[102] := 44; start[103] := 44; 
  start[104] := 44; start[105] := 44; start[106] := 44; start[107] := 44; 
  start[108] := 44; start[109] := 44; start[110] := 44; start[111] := 44; 
  start[112] := 44; start[113] := 44; start[114] := 44; start[115] := 44; 
  start[116] := 44; start[117] := 44; start[118] := 44; start[119] := 44; 
  start[120] := 44; start[121] := 44; start[122] := 44; start[123] := 44; 
  start[124] := 44; start[125] := 44; start[126] := 44; start[127] := 44; 
  start[128] := 44; start[129] := 44; start[130] := 44; start[131] := 44; 
  start[132] := 44; start[133] := 44; start[134] := 44; start[135] := 44; 
  start[136] := 44; start[137] := 44; start[138] := 44; start[139] := 44; 
  start[140] := 44; start[141] := 44; start[142] := 44; start[143] := 44; 
  start[144] := 44; start[145] := 44; start[146] := 44; start[147] := 44; 
  start[148] := 44; start[149] := 44; start[150] := 44; start[151] := 44; 
  start[152] := 44; start[153] := 44; start[154] := 44; start[155] := 44; 
  start[156] := 44; start[157] := 44; start[158] := 44; start[159] := 44; 
  start[160] := 44; start[161] := 44; start[162] := 44; start[163] := 44; 
  start[164] := 44; start[165] := 44; start[166] := 44; start[167] := 44; 
  start[168] := 44; start[169] := 44; start[170] := 44; start[171] := 44; 
  start[172] := 44; start[173] := 44; start[174] := 44; start[175] := 44; 
  start[176] := 44; start[177] := 44; start[178] := 44; start[179] := 44; 
  start[180] := 44; start[181] := 44; start[182] := 44; start[183] := 44; 
  start[184] := 44; start[185] := 44; start[186] := 44; start[187] := 44; 
  start[188] := 44; start[189] := 44; start[190] := 44; start[191] := 44; 
  start[192] := 44; start[193] := 44; start[194] := 44; start[195] := 44; 
  start[196] := 44; start[197] := 44; start[198] := 44; start[199] := 44; 
  start[200] := 44; start[201] := 44; start[202] := 44; start[203] := 44; 
  start[204] := 44; start[205] := 44; start[206] := 44; start[207] := 44; 
  start[208] := 44; start[209] := 44; start[210] := 44; start[211] := 44; 
  start[212] := 44; start[213] := 44; start[214] := 44; start[215] := 44; 
  start[216] := 44; start[217] := 44; start[218] := 44; start[219] := 44; 
  start[220] := 44; start[221] := 44; start[222] := 44; start[223] := 44; 
  start[224] := 44; start[225] := 44; start[226] := 44; start[227] := 44; 
  start[228] := 44; start[229] := 44; start[230] := 44; start[231] := 44; 
  start[232] := 44; start[233] := 44; start[234] := 44; start[235] := 44; 
  start[236] := 44; start[237] := 44; start[238] := 44; start[239] := 44; 
  start[240] := 44; start[241] := 44; start[242] := 44; start[243] := 44; 
  start[244] := 44; start[245] := 44; start[246] := 44; start[247] := 44; 
  start[248] := 44; start[249] := 44; start[250] := 44; start[251] := 44; 
  start[252] := 44; start[253] := 44; start[254] := 44; start[255] := 44; 
  Error := Err; LBlkSize := BlkSize; lastCh := EF;
END. (* Z80PasS *)
