UNIT Z80PasP;
(* Parser generated by Coco/R (Pascal version) *)

INTERFACE

PROCEDURE Parse;

FUNCTION Successful : BOOLEAN;
(* Returns TRUE if no errors have been recorded while parsing *)

PROCEDURE SynError (errNo: INTEGER);
(* Report syntax error with specified errNo *)

PROCEDURE SemError (errNo: INTEGER);
(* Report semantic error with specified errNo *)

PROCEDURE LexString (VAR Lex : STRING);
(* Retrieves Lex as exact spelling of current token *)

PROCEDURE LexName (VAR Lex : STRING);
(* Retrieves Lex as name of current token (capitalized if IGNORE CASE) *)

PROCEDURE LookAheadString (VAR Lex : STRING);
(* Retrieves Lex as exact spelling of lookahead token *)

PROCEDURE LookAheadName (VAR Lex : STRING);
(* Retrieves Lex as name of lookahead token (capitalized if IGNORE CASE) *)

IMPLEMENTATION

USES Z80PasS, Z80PasG (* Symbol Constants *);




CONST
  maxT = 147;
  minErrDist  =  2;  (* minimal distance (good tokens) between two errors *)
  setsize     = 16;  (* sets are stored in 16 bits *)

TYPE
  BITSET = SET OF 0 .. 15;
  SymbolSet = ARRAY [0 .. maxT DIV setsize] OF BITSET;

VAR
  symSet:  ARRAY [0 ..  12] OF SymbolSet; (*symSet[0] = allSyncSyms*)
  errDist: INTEGER;   (* number of symbols recognized since last error *)
  sym:     INTEGER;   (* current input symbol *)

PROCEDURE  SemError (errNo: INTEGER);
  BEGIN
    IF errDist >= minErrDist THEN BEGIN
      Z80PasS.Error(errNo, Z80PasS.line, Z80PasS.col, Z80PasS.pos);
    END;
    errDist := 0;
  END;

PROCEDURE  SynError (errNo: INTEGER);
  BEGIN
    IF errDist >= minErrDist THEN BEGIN
      Z80PasS.Error(errNo, Z80PasS.nextLine, Z80PasS.nextCol, Z80PasS.nextPos);
    END;
    errDist := 0;
  END;

PROCEDURE  Get;
  VAR
    s: STRING;
  BEGIN
    REPEAT
      Z80PasS.Get(sym);
      IF sym <= maxT THEN
        INC(errDist)
      ELSE BEGIN
        
      END;
    UNTIL sym <= maxT
  END;

FUNCTION  _In (VAR s: SymbolSet; x: INTEGER): BOOLEAN;
  BEGIN
    _In := x MOD setsize IN s[x DIV setsize];
  END;

PROCEDURE  Expect (n: INTEGER);
  BEGIN
    IF sym = n THEN Get ELSE SynError(n);
  END;

PROCEDURE  ExpectWeak (n, follow: INTEGER);
  BEGIN
    IF sym = n
    THEN Get
    ELSE BEGIN
      SynError(n); WHILE NOT _In(symSet[follow], sym) DO Get;
    END
  END;

FUNCTION  WeakSeparator (n, syFol, repFol: INTEGER): BOOLEAN;
  VAR
    s: SymbolSet;
    i: INTEGER;
  BEGIN
    IF sym = n
    THEN BEGIN Get; WeakSeparator := TRUE; EXIT; END
    ELSE IF _In(symSet[repFol], sym) THEN BEGIN WeakSeparator := FALSE; exit END
    ELSE BEGIN
      i := 0;
      WHILE i <= maxT DIV setsize DO BEGIN
        s[i] := symSet[0, i] + symSet[syFol, i] + symSet[repFol, i]; INC(i)
      END;
      SynError(n); WHILE NOT _In(s, sym) DO Get;
      WeakSeparator := _In(symSet[syFol], sym)
    END
  END;

PROCEDURE LexName (VAR Lex : STRING);
  BEGIN
    Z80PasS.GetName(Z80PasS.pos, Z80PasS.len, Lex)
  END;

PROCEDURE LexString (VAR Lex : STRING);
  BEGIN
    Z80PasS.GetString(Z80PasS.pos, Z80PasS.len, Lex)
  END;

PROCEDURE LookAheadName (VAR Lex : STRING);
  BEGIN
    Z80PasS.GetName(Z80PasS.nextPos, Z80PasS.nextLen, Lex)
  END;

PROCEDURE LookAheadString (VAR Lex : STRING);
  BEGIN
    Z80PasS.GetString(Z80PasS.nextPos, Z80PasS.nextLen, Lex)
  END;

FUNCTION Successful : BOOLEAN;
  BEGIN
    Successful := Z80PasS.errors = 0
  END;

PROCEDURE _Z80Register16bit; FORWARD;
PROCEDURE _Z80Register8bit; FORWARD;
PROCEDURE _Z80Register; FORWARD;
PROCEDURE _Z80Indirection; FORWARD;
PROCEDURE _Z80Condition; FORWARD;
PROCEDURE _Z80Integer; FORWARD;
PROCEDURE _Z80Parameter; FORWARD;
PROCEDURE _Z80Instruction; FORWARD;
PROCEDURE _Z80Statement; FORWARD;
PROCEDURE _Z80StatementSequence; FORWARD;
PROCEDURE _Member; FORWARD;
PROCEDURE _ExpList; FORWARD;
PROCEDURE _SetConstructor; FORWARD;
PROCEDURE _UnsignedLiteral; FORWARD;
PROCEDURE _MulOp; FORWARD;
PROCEDURE _Factor; FORWARD;
PROCEDURE _AddOp; FORWARD;
PROCEDURE _Term; FORWARD;
PROCEDURE _RelOp; FORWARD;
PROCEDURE _SimpleExpression; FORWARD;
PROCEDURE _RecVarList; FORWARD;
PROCEDURE _ControlVariable; FORWARD;
PROCEDURE _CaseLabel; FORWARD;
PROCEDURE _OneCase; FORWARD;
PROCEDURE _CaseList; FORWARD;
PROCEDURE _OrdinalExpression; FORWARD;
PROCEDURE _BooleanExpression; FORWARD;
PROCEDURE _IntegerExpression; FORWARD;
PROCEDURE _FieldWidth; FORWARD;
PROCEDURE _ActualParameter; FORWARD;
PROCEDURE _Expression; FORWARD;
PROCEDURE _ActualParams; FORWARD;
PROCEDURE _Value; FORWARD;
PROCEDURE _Designator; FORWARD;
PROCEDURE _WithStatement; FORWARD;
PROCEDURE _ForStatement; FORWARD;
PROCEDURE _CaseStatement; FORWARD;
PROCEDURE _IfStatement; FORWARD;
PROCEDURE _RepeatStatement; FORWARD;
PROCEDURE _WhileStatement; FORWARD;
PROCEDURE _AssignmentOrCall; FORWARD;
PROCEDURE _Statement; FORWARD;
PROCEDURE _StatementSequence; FORWARD;
PROCEDURE _ASMCompoundStatement; FORWARD;
PROCEDURE _CompoundStatement; FORWARD;
PROCEDURE _IndexSpec; FORWARD;
PROCEDURE _IndexSpecList; FORWARD;
PROCEDURE _ParamType; FORWARD;
PROCEDURE _ParamGroup; FORWARD;
PROCEDURE _FormalSection; FORWARD;
PROCEDURE _ReturnType; FORWARD;
PROCEDURE _FormalParams; FORWARD;
PROCEDURE _Body; FORWARD;
PROCEDURE _FuncHeading; FORWARD;
PROCEDURE _ProcHeading; FORWARD;
PROCEDURE _VarDecl; FORWARD;
PROCEDURE _CaseLabelList; FORWARD;
PROCEDURE _Variant; FORWARD;
PROCEDURE _VariantSelector; FORWARD;
PROCEDURE _RecordSection; FORWARD;
PROCEDURE _VariantPart; FORWARD;
PROCEDURE _fixedPart; FORWARD;
PROCEDURE _FieldList; FORWARD;
PROCEDURE _IndexList; FORWARD;
PROCEDURE _FileType; FORWARD;
PROCEDURE _SetType; FORWARD;
PROCEDURE _RecordType; FORWARD;
PROCEDURE _ArrayType; FORWARD;
PROCEDURE _NewIdentList; FORWARD;
PROCEDURE _SubrangeType; FORWARD;
PROCEDURE _EnumerationType; FORWARD;
PROCEDURE _TypeIdent; FORWARD;
PROCEDURE _StructType; FORWARD;
PROCEDURE _SimpleType; FORWARD;
PROCEDURE _Type; FORWARD;
PROCEDURE _TypeDef; FORWARD;
PROCEDURE _UnsignedReal; FORWARD;
PROCEDURE _UnsignedInt; FORWARD;
PROCEDURE _String; FORWARD;
PROCEDURE _ConstIdent; FORWARD;
PROCEDURE _UnsignedNumber; FORWARD;
PROCEDURE _Constant; FORWARD;
PROCEDURE _ConstDef; FORWARD;
PROCEDURE _ProcDeclarations; FORWARD;
PROCEDURE _VarDeclarations; FORWARD;
PROCEDURE _TypeDefinitions; FORWARD;
PROCEDURE _ConstDefinitions; FORWARD;
PROCEDURE _StatementPart; FORWARD;
PROCEDURE _DeclarationPart; FORWARD;
PROCEDURE _Block; FORWARD;
PROCEDURE _NewIdent; FORWARD;
PROCEDURE _PascalProgram; FORWARD;
PROCEDURE _Z80Pas; FORWARD;

PROCEDURE _Z80Register16bit;
  BEGIN
    CASE sym OF
      AFSym : BEGIN
        Get;
        END;
      HLSym : BEGIN
        Get;
        END;
      BCSym : BEGIN
        Get;
        END;
      DESym : BEGIN
        Get;
        END;
      IXSym : BEGIN
        Get;
        END;
      IYSym : BEGIN
        Get;
        END;
      SPSym : BEGIN
        Get;
        END;
      PCSym : BEGIN
        Get;
        END;
    ELSE BEGIN SynError(148);
        END;
    END;
  END;

PROCEDURE _Z80Register8bit;
  BEGIN
    CASE sym OF
      _ASym : BEGIN
        Get;
        END;
      _HSym : BEGIN
        Get;
        END;
      _LSym : BEGIN
        Get;
        END;
      _BSym : BEGIN
        Get;
        END;
      _CSym : BEGIN
        Get;
        END;
      _DSym : BEGIN
        Get;
        END;
      _ESym : BEGIN
        Get;
        END;
    ELSE BEGIN SynError(149);
        END;
    END;
  END;

PROCEDURE _Z80Register;
  BEGIN
    IF _In(symSet[1], sym) THEN BEGIN
      _Z80Register8bit;
    END ELSE IF _In(symSet[2], sym) THEN BEGIN
      _Z80Register16bit;
    END ELSE BEGIN SynError(150);
    END;
  END;

PROCEDURE _Z80Indirection;
  BEGIN
    Expect(_lbrackSym);
    IF (sym = BCSym) THEN BEGIN
      Get;
    END ELSE IF (sym = DESym) THEN BEGIN
      Get;
    END ELSE IF (sym = HLSym) THEN BEGIN
      Get;
    END ELSE IF (sym = integerSym) THEN BEGIN
      Get;
    END ELSE IF (sym = IXSym) OR
          (sym = IYSym) THEN BEGIN
      IF (sym = IXSym) THEN BEGIN
        Get;
      END ELSE BEGIN
        Get;
      END;
      Expect(_plusSym);
      Expect(integerSym);
    END ELSE BEGIN SynError(151);
    END;
    Expect(_rbrackSym);
  END;

PROCEDURE _Z80Condition;
  BEGIN
    CASE sym OF
      _MSym : BEGIN
        Get;
        END;
      NCSym : BEGIN
        Get;
        END;
      NPSym : BEGIN
        Get;
        END;
      NZSym : BEGIN
        Get;
        END;
      _PSym : BEGIN
        Get;
        END;
      PESym : BEGIN
        Get;
        END;
      POSym : BEGIN
        Get;
        END;
      _ZSym : BEGIN
        Get;
        END;
    ELSE BEGIN SynError(152);
        END;
    END;
  END;

PROCEDURE _Z80Integer;
  BEGIN
    IF (sym = integerSym) THEN BEGIN
      Get;
    END ELSE IF (sym = hexintegerSym) THEN BEGIN
      Get;
    END ELSE BEGIN SynError(153);
    END;
  END;

PROCEDURE _Z80Parameter;
  BEGIN
    IF (sym = integerSym) OR
       (sym = hexintegerSym) THEN BEGIN
      _Z80Integer;
    END ELSE IF _In(symSet[3], sym) THEN BEGIN
      _Z80Condition;
    END ELSE IF (sym = _lbrackSym) THEN BEGIN
      _Z80Indirection;
    END ELSE IF _In(symSet[4], sym) THEN BEGIN
      _Z80Register;
    END ELSE BEGIN SynError(154);
    END;
  END;

PROCEDURE _Z80Instruction;
  BEGIN
    CASE sym OF
      ADCSym : BEGIN
        Get;
        END;
      ADDSym : BEGIN
        Get;
        END;
      ANDSym : BEGIN
        Get;
        END;
      BITSym : BEGIN
        Get;
        END;
      CALLSym : BEGIN
        Get;
        END;
      CCFSym : BEGIN
        Get;
        END;
      CPSym : BEGIN
        Get;
        END;
      CPDSym : BEGIN
        Get;
        END;
      CPDRSym : BEGIN
        Get;
        END;
      CPISym : BEGIN
        Get;
        END;
      CPIRSym : BEGIN
        Get;
        END;
      CPLSym : BEGIN
        Get;
        END;
      DAASym : BEGIN
        Get;
        END;
      DECSym : BEGIN
        Get;
        END;
      DISym : BEGIN
        Get;
        END;
      DJNZ_commaSym : BEGIN
        Get;
        END;
      EISym : BEGIN
        Get;
        END;
      EXSym : BEGIN
        Get;
        END;
      EXXSym : BEGIN
        Get;
        END;
      HALTSym : BEGIN
        Get;
        END;
      IMSym : BEGIN
        Get;
        END;
      INSym : BEGIN
        Get;
        END;
      INCSym : BEGIN
        Get;
        END;
      INDSym : BEGIN
        Get;
        END;
      INDRSym : BEGIN
        Get;
        END;
      INISym : BEGIN
        Get;
        END;
      INIRSym : BEGIN
        Get;
        END;
      JPSym : BEGIN
        Get;
        END;
      JRSym : BEGIN
        Get;
        END;
      LDSym : BEGIN
        Get;
        END;
      LDDSym : BEGIN
        Get;
        END;
      LDDRSym : BEGIN
        Get;
        END;
      LDISym : BEGIN
        Get;
        END;
      LDIRSym : BEGIN
        Get;
        END;
      NEGSym : BEGIN
        Get;
        END;
      NOPSym : BEGIN
        Get;
        END;
      ORSym : BEGIN
        Get;
        END;
      OTDRSym : BEGIN
        Get;
        END;
      OTIRSym : BEGIN
        Get;
        END;
      OUTSym : BEGIN
        Get;
        END;
      OUTDSym : BEGIN
        Get;
        END;
      OUTISym : BEGIN
        Get;
        END;
      POPSym : BEGIN
        Get;
        END;
      PUSHSym : BEGIN
        Get;
        END;
      RESSym : BEGIN
        Get;
        END;
      RETSym : BEGIN
        Get;
        END;
      RETISym : BEGIN
        Get;
        END;
      RETNSym : BEGIN
        Get;
        END;
      RLSym : BEGIN
        Get;
        END;
      RLASym : BEGIN
        Get;
        END;
      RLCSym : BEGIN
        Get;
        END;
      RLCASym : BEGIN
        Get;
        END;
      RLDSym : BEGIN
        Get;
        END;
      RRSym : BEGIN
        Get;
        END;
      RRASym : BEGIN
        Get;
        END;
      RRCSym : BEGIN
        Get;
        END;
      RRDSym : BEGIN
        Get;
        END;
      RSTSym : BEGIN
        Get;
        END;
      SCFSym : BEGIN
        Get;
        END;
      SETSym : BEGIN
        Get;
        END;
      SLASym : BEGIN
        Get;
        END;
      SRASym : BEGIN
        Get;
        END;
      SBCSym : BEGIN
        Get;
        END;
      SUBSym : BEGIN
        Get;
        END;
      XORSym : BEGIN
        Get;
        END;
    ELSE BEGIN SynError(155);
        END;
    END;
  END;

PROCEDURE _Z80Statement;
  BEGIN
    _Z80Instruction;
    IF _In(symSet[5], sym) THEN BEGIN
      _Z80Parameter;
      IF (sym = _commaSym) THEN BEGIN
        Get;
        _Z80Parameter;
      END;
    END;
  END;

PROCEDURE _Z80StatementSequence;
  BEGIN
    _Z80Statement;
    WHILE (sym = _semicolonSym) DO BEGIN
      Get;
      _Z80Statement;
    END;
  END;

PROCEDURE _Member;
  BEGIN
    _Expression;
    IF (sym = _point_pointSym) THEN BEGIN
      Get;
      _Expression;
    END;
  END;

PROCEDURE _ExpList;
  BEGIN
    _Expression;
    WHILE (sym = _commaSym) DO BEGIN
      Get;
      _Expression;
    END;
  END;

PROCEDURE _SetConstructor;
  BEGIN
    Expect(_lbrackSym);
    _Member;
    WHILE (sym = _commaSym) DO BEGIN
      Get;
      _Member;
    END;
    Expect(_rbrackSym);
  END;

PROCEDURE _UnsignedLiteral;
  BEGIN
    IF (sym = integerSym) OR
       (sym = hexintegerSym) OR
       (sym = realSym) THEN BEGIN
      _UnsignedNumber;
    END ELSE IF (sym = NILSym) THEN BEGIN
      Get;
    END ELSE IF (sym = stringSym) THEN BEGIN
      _String;
    END ELSE BEGIN SynError(156);
    END;
  END;

PROCEDURE _MulOp;
  BEGIN
    IF (sym = _starSym) THEN BEGIN
      Get;
    END ELSE IF (sym = _slashSym) THEN BEGIN
      Get;
    END ELSE IF (sym = DIVSym) THEN BEGIN
      Get;
    END ELSE IF (sym = MODSym) THEN BEGIN
      Get;
    END ELSE IF (sym = ANDSym) THEN BEGIN
      Get;
    END ELSE BEGIN SynError(157);
    END;
  END;

PROCEDURE _Factor;
  BEGIN
    IF (sym = identifierSym) THEN BEGIN
      _Designator;
      IF (sym = _lparenSym) THEN BEGIN
        _ActualParams;
      END;
    END ELSE IF (sym = integerSym) OR
          (sym = hexintegerSym) OR
          (sym = realSym) OR
          (sym = stringSym) OR
          (sym = NILSym) THEN BEGIN
      _UnsignedLiteral;
    END ELSE IF (sym = _lbrackSym) THEN BEGIN
      _SetConstructor;
    END ELSE IF (sym = _lparenSym) THEN BEGIN
      Get;
      _Expression;
      Expect(_rparenSym);
    END ELSE IF (sym = NOTSym) THEN BEGIN
      Get;
      _Factor;
    END ELSE BEGIN SynError(158);
    END;
  END;

PROCEDURE _AddOp;
  BEGIN
    IF (sym = _plusSym) THEN BEGIN
      Get;
    END ELSE IF (sym = _minusSym) THEN BEGIN
      Get;
    END ELSE IF (sym = ORSym) THEN BEGIN
      Get;
    END ELSE BEGIN SynError(159);
    END;
  END;

PROCEDURE _Term;
  BEGIN
    _Factor;
    WHILE (sym = _starSym) OR
          (sym = _slashSym) OR
          (sym = DIVSym) OR
          (sym = MODSym) OR
          (sym = ANDSym) DO BEGIN
      _MulOp;
      _Factor;
    END;
  END;

PROCEDURE _RelOp;
  BEGIN
    CASE sym OF
      _equalSym : BEGIN
        Get;
        END;
      _lessSym : BEGIN
        Get;
        END;
      _greaterSym : BEGIN
        Get;
        END;
      _less_equalSym : BEGIN
        Get;
        END;
      _greater_equalSym : BEGIN
        Get;
        END;
      _less_greaterSym : BEGIN
        Get;
        END;
      INSym : BEGIN
        Get;
        END;
    ELSE BEGIN SynError(160);
        END;
    END;
  END;

PROCEDURE _SimpleExpression;
  BEGIN
    IF (sym = _plusSym) THEN BEGIN
      Get;
      _Term;
    END ELSE IF (sym = _minusSym) THEN BEGIN
      Get;
      _Term;
    END ELSE IF _In(symSet[6], sym) THEN BEGIN
      _Term;
    END ELSE BEGIN SynError(161);
    END;
    WHILE (sym = _plusSym) OR
          (sym = _minusSym) OR
          (sym = ORSym) DO BEGIN
      _AddOp;
      _Term;
    END;
  END;

PROCEDURE _RecVarList;
  BEGIN
    _Designator;
    WHILE (sym = _commaSym) DO BEGIN
      Get;
      _Designator;
    END;
  END;

PROCEDURE _ControlVariable;
  BEGIN
    Expect(identifierSym);
  END;

PROCEDURE _CaseLabel;
  BEGIN
    _Constant;
  END;

PROCEDURE _OneCase;
  BEGIN
    _CaseLabelList;
    Expect(_colonSym);
    _Statement;
  END;

PROCEDURE _CaseList;
  BEGIN
    _OneCase;
    WHILE (sym = _semicolonSym) DO BEGIN
      Get;
      _OneCase;
    END;
    IF (sym = _semicolonSym) THEN BEGIN
      Get;
    END;
  END;

PROCEDURE _OrdinalExpression;
  BEGIN
    _Expression;
  END;

PROCEDURE _BooleanExpression;
  BEGIN
    _Expression;
  END;

PROCEDURE _IntegerExpression;
  BEGIN
    _Expression;
  END;

PROCEDURE _FieldWidth;
  BEGIN
    Expect(_colonSym);
    _IntegerExpression;
    IF (sym = _colonSym) THEN BEGIN
      Get;
      _IntegerExpression;
    END;
  END;

PROCEDURE _ActualParameter;
  BEGIN
    _Value;
    IF (sym = _colonSym) THEN BEGIN
      _FieldWidth;
    END;
  END;

PROCEDURE _Expression;
  BEGIN
    _SimpleExpression;
    IF _In(symSet[7], sym) THEN BEGIN
      _RelOp;
      _SimpleExpression;
    END;
  END;

PROCEDURE _ActualParams;
  BEGIN
    Expect(_lparenSym);
    _ActualParameter;
    WHILE (sym = _commaSym) DO BEGIN
      Get;
      _ActualParameter;
    END;
    Expect(_rparenSym);
  END;

PROCEDURE _Value;
  BEGIN
    IF (sym = _atSym) THEN BEGIN
      Get;
      _Designator;
    END ELSE IF _In(symSet[8], sym) THEN BEGIN
      _Expression;
    END ELSE BEGIN SynError(162);
    END;
  END;

PROCEDURE _Designator;
  BEGIN
    Expect(identifierSym);
    WHILE (sym = _pointSym) OR
          (sym = _uparrowSym) OR
          (sym = _lbrackSym) DO BEGIN
      IF (sym = _pointSym) THEN BEGIN
        Get;
        Expect(identifierSym);
      END ELSE IF (sym = _lbrackSym) THEN BEGIN
        Get;
        _ExpList;
        Expect(_rbrackSym);
      END ELSE BEGIN
        Get;
      END;
    END;
  END;

PROCEDURE _WithStatement;
  BEGIN
    Expect(WITHSym);
    _RecVarList;
    Expect(DOSym);
    _Statement;
  END;

PROCEDURE _ForStatement;
  BEGIN
    Expect(FORSym);
    _ControlVariable;
    Expect(_colon_equalSym);
    _OrdinalExpression;
    IF (sym = TOSym) THEN BEGIN
      Get;
    END ELSE IF (sym = DOWNTOSym) THEN BEGIN
      Get;
    END ELSE BEGIN SynError(163);
    END;
    _OrdinalExpression;
    Expect(DOSym);
    _Statement;
  END;

PROCEDURE _CaseStatement;
  BEGIN
    Expect(CASESym);
    _OrdinalExpression;
    Expect(OFSym);
    _CaseList;
    Expect(ENDSym);
  END;

PROCEDURE _IfStatement;
  BEGIN
    Expect(IFSym);
    _BooleanExpression;
    Expect(THENSym);
    _Statement;
    IF (sym = ELSESym) THEN BEGIN
      Get;
      _Statement;
    END;
  END;

PROCEDURE _RepeatStatement;
  BEGIN
    Expect(REPEATSym);
    _StatementSequence;
    Expect(UNTILSym);
    _BooleanExpression;
  END;

PROCEDURE _WhileStatement;
  BEGIN
    Expect(WHILESym);
    _BooleanExpression;
    Expect(DOSym);
    _Statement;
  END;

PROCEDURE _AssignmentOrCall;
  BEGIN
    _Designator;
    IF (sym = _colon_equalSym) THEN BEGIN
      Get;
      _Value;
    END ELSE IF (sym = _semicolonSym) OR
          (sym = _lparenSym) OR
          (sym = ENDSym) OR
          (sym = UNTILSym) OR
          (sym = ELSESym) THEN BEGIN
      IF (sym = _lparenSym) THEN BEGIN
        _ActualParams;
      END;
    END ELSE BEGIN SynError(164);
    END;
  END;

PROCEDURE _Statement;
  BEGIN
    IF _In(symSet[9], sym) THEN BEGIN
      CASE sym OF
        identifierSym : BEGIN
          _AssignmentOrCall;
          END;
        BEGINSym : BEGIN
          _CompoundStatement;
          END;
        ASMSym : BEGIN
          _ASMCompoundStatement;
          END;
        WHILESym : BEGIN
          _WhileStatement;
          END;
        REPEATSym : BEGIN
          _RepeatStatement;
          END;
        IFSym : BEGIN
          _IfStatement;
          END;
        CASESym : BEGIN
          _CaseStatement;
          END;
        FORSym : BEGIN
          _ForStatement;
          END;
        WITHSym : BEGIN
          _WithStatement;
          END;
      END;
    END;
  END;

PROCEDURE _StatementSequence;
  BEGIN
    _Statement;
    WHILE (sym = _semicolonSym) DO BEGIN
      Get;
      _Statement;
    END;
  END;

PROCEDURE _ASMCompoundStatement;
  BEGIN
    Expect(ASMSym);
    IF _In(symSet[10], sym) THEN BEGIN
      _Z80StatementSequence;
    END;
    Expect(ENDSym);
  END;

PROCEDURE _CompoundStatement;
  BEGIN
    Expect(BEGINSym);
    _StatementSequence;
    Expect(ENDSym);
  END;

PROCEDURE _IndexSpec;
  BEGIN
    _NewIdent;
    Expect(_point_pointSym);
    _NewIdent;
    Expect(_colonSym);
    _TypeIdent;
  END;

PROCEDURE _IndexSpecList;
  BEGIN
    _IndexSpec;
    WHILE (sym = _semicolonSym) DO BEGIN
      Get;
      _IndexSpec;
    END;
  END;

PROCEDURE _ParamType;
  BEGIN
    IF (sym = identifierSym) THEN BEGIN
      _TypeIdent;
    END ELSE IF (sym = ARRAYSym) THEN BEGIN
      Get;
      Expect(_lbrackSym);
      _IndexSpecList;
      Expect(_rbrackSym);
      Expect(OFSym);
      _ParamType;
    END ELSE IF (sym = PACKEDSym) THEN BEGIN
      Get;
      Expect(ARRAYSym);
      Expect(_lbrackSym);
      _IndexSpec;
      Expect(_rbrackSym);
      Expect(OFSym);
      _TypeIdent;
    END ELSE BEGIN SynError(165);
    END;
  END;

PROCEDURE _ParamGroup;
  BEGIN
    _NewIdentList;
    Expect(_colonSym);
    _ParamType;
  END;

PROCEDURE _FormalSection;
  BEGIN
    IF (sym = identifierSym) OR
       (sym = VARSym) THEN BEGIN
      IF (sym = VARSym) THEN BEGIN
        Get;
      END;
      _ParamGroup;
    END ELSE IF (sym = PROCEDURESym) THEN BEGIN
      _ProcHeading;
    END ELSE IF (sym = FUNCTIONSym) THEN BEGIN
      _FuncHeading;
    END ELSE BEGIN SynError(166);
    END;
  END;

PROCEDURE _ReturnType;
  BEGIN
    IF (sym = _colonSym) THEN BEGIN
      Get;
      _TypeIdent;
    END;
  END;

PROCEDURE _FormalParams;
  BEGIN
    Expect(_lparenSym);
    _FormalSection;
    WHILE (sym = _semicolonSym) DO BEGIN
      Get;
      _FormalSection;
    END;
    Expect(_rparenSym);
  END;

PROCEDURE _Body;
  BEGIN
    IF _In(symSet[11], sym) THEN BEGIN
      _Block;
    END ELSE IF (sym = FORWARDSym) THEN BEGIN
      Get;
    END ELSE BEGIN SynError(167);
    END;
  END;

PROCEDURE _FuncHeading;
  BEGIN
    Expect(FUNCTIONSym);
    _NewIdent;
    IF (sym = _lparenSym) THEN BEGIN
      _FormalParams;
    END;
    _ReturnType;
  END;

PROCEDURE _ProcHeading;
  BEGIN
    Expect(PROCEDURESym);
    _NewIdent;
    IF (sym = _lparenSym) THEN BEGIN
      _FormalParams;
    END;
  END;

PROCEDURE _VarDecl;
  BEGIN
    _NewIdentList;
    Expect(_colonSym);
    _Type;
    Expect(_semicolonSym);
  END;

PROCEDURE _CaseLabelList;
  BEGIN
    _CaseLabel;
    WHILE (sym = _commaSym) DO BEGIN
      Get;
      _CaseLabel;
    END;
  END;

PROCEDURE _Variant;
  BEGIN
    _CaseLabelList;
    Expect(_colonSym);
    Expect(_lparenSym);
    _FieldList;
    Expect(_rparenSym);
  END;

PROCEDURE _VariantSelector;
  BEGIN
    IF (sym = identifierSym) THEN BEGIN
      _NewIdent;
      Expect(_colonSym);
    END;
    _TypeIdent;
  END;

PROCEDURE _RecordSection;
  BEGIN
    _NewIdentList;
    Expect(_colonSym);
    _Type;
  END;

PROCEDURE _VariantPart;
  BEGIN
    Expect(CASESym);
    _VariantSelector;
    Expect(OFSym);
    _Variant;
    WHILE (sym = _semicolonSym) DO BEGIN
      Get;
      _Variant;
    END;
  END;

PROCEDURE _fixedPart;
  BEGIN
    _RecordSection;
    WHILE (sym = _semicolonSym) DO BEGIN
      Get;
      _RecordSection;
    END;
  END;

PROCEDURE _FieldList;
  BEGIN
    IF (sym = identifierSym) OR
       (sym = CASESym) THEN BEGIN
      IF (sym = identifierSym) THEN BEGIN
        _fixedPart;
        IF (sym = _semicolonSym) THEN BEGIN
          Get;
          _VariantPart;
        END;
      END ELSE BEGIN
        _VariantPart;
      END;
      IF (sym = _semicolonSym) THEN BEGIN
        Get;
      END;
    END;
  END;

PROCEDURE _IndexList;
  BEGIN
    _SimpleType;
    WHILE (sym = _commaSym) DO BEGIN
      Get;
      _SimpleType;
    END;
  END;

PROCEDURE _FileType;
  BEGIN
    Expect(FILESym);
    Expect(OFSym);
    _Type;
  END;

PROCEDURE _SetType;
  BEGIN
    Expect(SETSym);
    Expect(OFSym);
    _SimpleType;
  END;

PROCEDURE _RecordType;
  BEGIN
    Expect(RECORDSym);
    _FieldList;
    Expect(ENDSym);
  END;

PROCEDURE _ArrayType;
  BEGIN
    Expect(ARRAYSym);
    Expect(_lbrackSym);
    _IndexList;
    Expect(_rbrackSym);
    Expect(OFSym);
    _Type;
  END;

PROCEDURE _NewIdentList;
  BEGIN
    _NewIdent;
    WHILE (sym = _commaSym) DO BEGIN
      Get;
      _NewIdent;
    END;
  END;

PROCEDURE _SubrangeType;
  BEGIN
    _Constant;
    Expect(_point_pointSym);
    _Constant;
  END;

PROCEDURE _EnumerationType;
  BEGIN
    Expect(_lparenSym);
    _NewIdentList;
    Expect(_rparenSym);
  END;

PROCEDURE _TypeIdent;
  BEGIN
    Expect(identifierSym);
  END;

PROCEDURE _StructType;
  BEGIN
    IF (sym = ARRAYSym) THEN BEGIN
      _ArrayType;
    END ELSE IF (sym = RECORDSym) THEN BEGIN
      _RecordType;
    END ELSE IF (sym = SETSym) THEN BEGIN
      _SetType;
    END ELSE IF (sym = FILESym) THEN BEGIN
      _FileType;
    END ELSE BEGIN SynError(168);
    END;
  END;

PROCEDURE _SimpleType;
  BEGIN
    IF (sym = identifierSym) THEN BEGIN
      _TypeIdent;
    END ELSE IF (sym = _lparenSym) THEN BEGIN
      _EnumerationType;
    END ELSE IF (sym < 16) (* prevent range error *) AND
          (sym IN [identifierSym, integerSym, hexintegerSym, realSym, 
                    stringSym, _plusSym, _minusSym])  THEN BEGIN
      _SubrangeType;
    END ELSE BEGIN SynError(169);
    END;
  END;

PROCEDURE _Type;
  BEGIN
    IF _In(symSet[12], sym) THEN BEGIN
      _SimpleType;
    END ELSE IF (sym = PACKEDSym) OR
          (sym = ARRAYSym) OR
          (sym = RECORDSym) OR
          (sym = SETSym) OR
          (sym = FILESym) THEN BEGIN
      IF (sym = PACKEDSym) THEN BEGIN
        Get;
      END;
      _StructType;
    END ELSE IF (sym = _uparrowSym) THEN BEGIN
      Get;
      _TypeIdent;
    END ELSE BEGIN SynError(170);
    END;
  END;

PROCEDURE _TypeDef;
  BEGIN
    _NewIdent;
    Expect(_equalSym);
    _Type;
    Expect(_semicolonSym);
  END;

PROCEDURE _UnsignedReal;
  BEGIN
    Expect(realSym);
  END;

PROCEDURE _UnsignedInt;
  BEGIN
    IF (sym = integerSym) THEN BEGIN
      Get;
    END ELSE IF (sym = hexintegerSym) THEN BEGIN
      Get;
    END ELSE BEGIN SynError(171);
    END;
  END;

PROCEDURE _String;
  BEGIN
    Expect(stringSym);
  END;

PROCEDURE _ConstIdent;
  BEGIN
    Expect(identifierSym);
  END;

PROCEDURE _UnsignedNumber;
  BEGIN
    IF (sym = integerSym) OR
       (sym = hexintegerSym) THEN BEGIN
      _UnsignedInt;
    END ELSE IF (sym = realSym) THEN BEGIN
      _UnsignedReal;
    END ELSE BEGIN SynError(172);
    END;
  END;

PROCEDURE _Constant;
  BEGIN
    IF (sym < 16) (* prevent range error *) AND
       (sym IN [identifierSym, integerSym, hexintegerSym, realSym, 
                    _plusSym, _minusSym])  THEN BEGIN
      IF (sym = _plusSym) OR
         (sym = _minusSym) THEN BEGIN
        IF (sym = _plusSym) THEN BEGIN
          Get;
        END ELSE BEGIN
          Get;
        END;
      END;
      IF (sym = integerSym) OR
         (sym = hexintegerSym) OR
         (sym = realSym) THEN BEGIN
        _UnsignedNumber;
      END ELSE IF (sym = identifierSym) THEN BEGIN
        _ConstIdent;
      END ELSE BEGIN SynError(173);
      END;
    END ELSE IF (sym = stringSym) THEN BEGIN
      _String;
    END ELSE BEGIN SynError(174);
    END;
  END;

PROCEDURE _ConstDef;
  BEGIN
    _NewIdent;
    Expect(_equalSym);
    _Constant;
    Expect(_semicolonSym);
  END;

PROCEDURE _ProcDeclarations;
  BEGIN
    IF (sym = PROCEDURESym) THEN BEGIN
      _ProcHeading;
    END ELSE IF (sym = FUNCTIONSym) THEN BEGIN
      _FuncHeading;
    END ELSE BEGIN SynError(175);
    END;
    Expect(_semicolonSym);
    _Body;
    Expect(_semicolonSym);
  END;

PROCEDURE _VarDeclarations;
  BEGIN
    IF (sym = VARSym) THEN BEGIN
      Get;
      _VarDecl;
      WHILE (sym = identifierSym) DO BEGIN
        _VarDecl;
      END;
    END;
  END;

PROCEDURE _TypeDefinitions;
  BEGIN
    IF (sym = TYPESym) THEN BEGIN
      Get;
      _TypeDef;
      WHILE (sym = identifierSym) DO BEGIN
        _TypeDef;
      END;
    END;
  END;

PROCEDURE _ConstDefinitions;
  BEGIN
    IF (sym = CONSTSym) THEN BEGIN
      Get;
      _ConstDef;
      WHILE (sym = identifierSym) DO BEGIN
        _ConstDef;
      END;
    END;
  END;

PROCEDURE _StatementPart;
  BEGIN
    IF (sym = BEGINSym) THEN BEGIN
      _CompoundStatement;
    END ELSE IF (sym = ASMSym) THEN BEGIN
      _ASMCompoundStatement;
    END ELSE BEGIN SynError(176);
    END;
  END;

PROCEDURE _DeclarationPart;
  BEGIN
    _ConstDefinitions;
    _TypeDefinitions;
    _VarDeclarations;
    WHILE (sym = PROCEDURESym) OR
          (sym = FUNCTIONSym) DO BEGIN
      _ProcDeclarations;
    END;
  END;

PROCEDURE _Block;
  BEGIN
    _DeclarationPart;
    _StatementPart;
  END;

PROCEDURE _NewIdent;
  BEGIN
    Expect(identifierSym);
  END;

PROCEDURE _PascalProgram;
  BEGIN
    Expect(PROGRAMSym);
    _NewIdent;
    Expect(_semicolonSym);
    _Block;
    Expect(_pointSym);
  END;

PROCEDURE _Z80Pas;
  BEGIN
    _PascalProgram;
  END;



PROCEDURE  Parse;
  BEGIN
    _Reset; Get;
    _Z80Pas;

  END;

BEGIN
  errDist := minErrDist;
  symSet[ 0, 0] := [EOFSYMB];
  symSet[ 0, 1] := [];
  symSet[ 0, 2] := [];
  symSet[ 0, 3] := [];
  symSet[ 0, 4] := [];
  symSet[ 0, 5] := [];
  symSet[ 0, 6] := [];
  symSet[ 0, 7] := [];
  symSet[ 0, 8] := [];
  symSet[ 0, 9] := [];
  symSet[ 1, 0] := [];
  symSet[ 1, 1] := [];
  symSet[ 1, 2] := [];
  symSet[ 1, 3] := [];
  symSet[ 1, 4] := [];
  symSet[ 1, 5] := [];
  symSet[ 1, 6] := [];
  symSet[ 1, 7] := [];
  symSet[ 1, 8] := [_ASym-128, _HSym-128, _LSym-128, _BSym-128, _CSym-128, _DSym-128, 
                    _ESym-128];
  symSet[ 1, 9] := [];
  symSet[ 2, 0] := [];
  symSet[ 2, 1] := [];
  symSet[ 2, 2] := [];
  symSet[ 2, 3] := [];
  symSet[ 2, 4] := [];
  symSet[ 2, 5] := [];
  symSet[ 2, 6] := [];
  symSet[ 2, 7] := [];
  symSet[ 2, 8] := [BCSym-128, DESym-128, HLSym-128, IXSym-128, IYSym-128];
  symSet[ 2, 9] := [AFSym-144, SPSym-144, PCSym-144];
  symSet[ 3, 0] := [];
  symSet[ 3, 1] := [];
  symSet[ 3, 2] := [];
  symSet[ 3, 3] := [];
  symSet[ 3, 4] := [];
  symSet[ 3, 5] := [];
  symSet[ 3, 6] := [];
  symSet[ 3, 7] := [_MSym-112, NCSym-112, NPSym-112, NZSym-112];
  symSet[ 3, 8] := [_PSym-128, PESym-128, POSym-128, _ZSym-128];
  symSet[ 3, 9] := [];
  symSet[ 4, 0] := [];
  symSet[ 4, 1] := [];
  symSet[ 4, 2] := [];
  symSet[ 4, 3] := [];
  symSet[ 4, 4] := [];
  symSet[ 4, 5] := [];
  symSet[ 4, 6] := [];
  symSet[ 4, 7] := [];
  symSet[ 4, 8] := [BCSym-128, DESym-128, HLSym-128, IXSym-128, IYSym-128, _ASym-128, 
                    _HSym-128, _LSym-128, _BSym-128, _CSym-128, _DSym-128, _ESym-128];
  symSet[ 4, 9] := [AFSym-144, SPSym-144, PCSym-144];
  symSet[ 5, 0] := [integerSym, hexintegerSym];
  symSet[ 5, 1] := [_lbrackSym-16];
  symSet[ 5, 2] := [];
  symSet[ 5, 3] := [];
  symSet[ 5, 4] := [];
  symSet[ 5, 5] := [];
  symSet[ 5, 6] := [];
  symSet[ 5, 7] := [_MSym-112, NCSym-112, NPSym-112, NZSym-112];
  symSet[ 5, 8] := [_PSym-128, PESym-128, POSym-128, _ZSym-128, BCSym-128, DESym-128, 
                    HLSym-128, IXSym-128, IYSym-128, _ASym-128, _HSym-128, _LSym-128, 
                    _BSym-128, _CSym-128, _DSym-128, _ESym-128];
  symSet[ 5, 9] := [AFSym-144, SPSym-144, PCSym-144];
  symSet[ 6, 0] := [identifierSym, integerSym, hexintegerSym, realSym, 
                    stringSym];
  symSet[ 6, 1] := [_lparenSym-16, _lbrackSym-16];
  symSet[ 6, 2] := [];
  symSet[ 6, 3] := [NOTSym-48, NILSym-48];
  symSet[ 6, 4] := [];
  symSet[ 6, 5] := [];
  symSet[ 6, 6] := [];
  symSet[ 6, 7] := [];
  symSet[ 6, 8] := [];
  symSet[ 6, 9] := [];
  symSet[ 7, 0] := [_equalSym];
  symSet[ 7, 1] := [];
  symSet[ 7, 2] := [];
  symSet[ 7, 3] := [_lessSym-48, _greaterSym-48, _less_equalSym-48, 
                    _greater_equalSym-48, _less_greaterSym-48, INSym-48];
  symSet[ 7, 4] := [];
  symSet[ 7, 5] := [];
  symSet[ 7, 6] := [];
  symSet[ 7, 7] := [];
  symSet[ 7, 8] := [];
  symSet[ 7, 9] := [];
  symSet[ 8, 0] := [identifierSym, integerSym, hexintegerSym, realSym, 
                    stringSym, _plusSym, _minusSym];
  symSet[ 8, 1] := [_lparenSym-16, _lbrackSym-16];
  symSet[ 8, 2] := [];
  symSet[ 8, 3] := [NOTSym-48, NILSym-48];
  symSet[ 8, 4] := [];
  symSet[ 8, 5] := [];
  symSet[ 8, 6] := [];
  symSet[ 8, 7] := [];
  symSet[ 8, 8] := [];
  symSet[ 8, 9] := [];
  symSet[ 9, 0] := [identifierSym];
  symSet[ 9, 1] := [CASESym-16];
  symSet[ 9, 2] := [BEGINSym-32, WHILESym-32, REPEATSym-32, IFSym-32, FORSym-32, 
                    WITHSym-32];
  symSet[ 9, 3] := [ASMSym-48];
  symSet[ 9, 4] := [];
  symSet[ 9, 5] := [];
  symSet[ 9, 6] := [];
  symSet[ 9, 7] := [];
  symSet[ 9, 8] := [];
  symSet[ 9, 9] := [];
  symSet[10, 0] := [];
  symSet[10, 1] := [SETSym-16];
  symSet[10, 2] := [];
  symSet[10, 3] := [INSym-48, ORSym-48, ANDSym-48, ADCSym-48];
  symSet[10, 4] := [ADDSym-64, BITSym-64, CALLSym-64, CCFSym-64, CPSym-64, 
                    CPDSym-64, CPDRSym-64, CPISym-64, CPIRSym-64, CPLSym-64, 
                    DAASym-64, DECSym-64, DISym-64, DJNZ_commaSym-64, EISym-64, 
                    EXSym-64];
  symSet[10, 5] := [EXXSym-80, HALTSym-80, IMSym-80, INCSym-80, INDSym-80, 
                    INDRSym-80, INISym-80, INIRSym-80, JPSym-80, JRSym-80, 
                    LDSym-80, LDDSym-80, LDDRSym-80, LDISym-80, LDIRSym-80, 
                    NEGSym-80];
  symSet[10, 6] := [NOPSym-96, OTDRSym-96, OTIRSym-96, OUTSym-96, OUTDSym-96, 
                    OUTISym-96, POPSym-96, PUSHSym-96, RESSym-96, RETSym-96, 
                    RETISym-96, RETNSym-96, RLSym-96, RLASym-96, RLCSym-96, 
                    RLCASym-96];
  symSet[10, 7] := [RLDSym-112, RRSym-112, RRASym-112, RRCSym-112, RRDSym-112, 
                    RSTSym-112, SCFSym-112, SLASym-112, SRASym-112, SBCSym-112, 
                    SUBSym-112, XORSym-112];
  symSet[10, 8] := [];
  symSet[10, 9] := [];
  symSet[11, 0] := [CONSTSym, TYPESym];
  symSet[11, 1] := [VARSym-16, PROCEDURESym-16];
  symSet[11, 2] := [FUNCTIONSym-32, BEGINSym-32];
  symSet[11, 3] := [ASMSym-48];
  symSet[11, 4] := [];
  symSet[11, 5] := [];
  symSet[11, 6] := [];
  symSet[11, 7] := [];
  symSet[11, 8] := [];
  symSet[11, 9] := [];
  symSet[12, 0] := [identifierSym, integerSym, hexintegerSym, realSym, 
                    stringSym, _plusSym, _minusSym];
  symSet[12, 1] := [_lparenSym-16];
  symSet[12, 2] := [];
  symSet[12, 3] := [];
  symSet[12, 4] := [];
  symSet[12, 5] := [];
  symSet[12, 6] := [];
  symSet[12, 7] := [];
  symSet[12, 8] := [];
  symSet[12, 9] := [];
END. (* Z80PasP *)
